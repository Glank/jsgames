<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
/* Style the button */
button {
  padding: 20px;
  font-size: 20px;
}

div {
  height: 200px;
  position: relative;
}
</style>
</head>
<body>


<button id="open_fullscreen">Open Fullscreen</button>

<div id="game">
</div>

<script type="module">
import {initGame, tryFullscreen, isFullscreen} from "../game_utils.mjs";
import {isMobileBrowser} from "../mobile_check.js";
import * as collision from "../collision.mjs";
import * as mtx from "../mtx.mjs";
(function() {
	var div = document.getElementById("game");
	var game = initGame(div, 480, 480*2);
  var engine = new collision.CollisionEngine();

  var ball = collision.initCircle([game.width/2, game.height/2], 20);
  var ballPhysics = new collision.BasicPhysics("bounce", {
    enforce_no_overlap: function(other) { return other.type === 'rline'; }
  });
  var angle = Math.PI*(1.25+Math.random()*0.5);
  var speed = 500;
  mtx.set_v2(speed*Math.cos(angle), speed*Math.sin(angle), ballPhysics.velocity);
  engine.addBody(ball, ballPhysics);

  var bounding_walls = [
    [[0,0], [1,0]], // left
    [[0,0], [0,1]], // top
    [[game.width,0], [-1,0]], // right
    [[0,game.height], [0,-1]], // bottom
  ];
  for (var i in bounding_walls) {
    var point = bounding_walls[i][0];
    var normal = bounding_walls[i][1];
    engine.addBody(collision.initInfiniteBoundary(point, normal));
  }

  var paddleLength = 150;
  var paddleYOffset = 100;
  var paddleRadius = 10;
  var paddleAngularSpeed = 3; // radians/second
  var paddleSpeed = 1000; // pxls/second
  var playerPaddle = collision.initRoundedLine(
    [game.width/2-paddleLength/2, game.height-paddleYOffset],
    [game.width/2+paddleLength/2, game.height-paddleYOffset],
    paddleRadius
  );
  var aiPaddle = collision.initRoundedLine(
    [game.width/2-paddleLength/2, paddleYOffset],
    [game.width/2+paddleLength/2, paddleYOffset],
    paddleRadius
  );
  var paddlePhysicsParams = {
    enforce_no_overlap: function(other) { return other.type === 'inf_bound'; },
    ignore: function(other) { return other.type === 'circle'; }
  };
  var playerPaddlePhysics = new collision.BasicPhysics("stop", paddlePhysicsParams);
  var aiPaddlePhysics = new collision.BasicPhysics("stop", paddlePhysicsParams);
  engine.addBody(playerPaddle, playerPaddlePhysics);
  engine.addBody(aiPaddle, aiPaddlePhysics);

	game.draw = function(ctx) {
    ctx.beginPath();
		ctx.arc(ball.get('center')[0], ball.get('center')[1], ball.get('radius'), 0, 2*Math.PI);
    ctx.closePath();
    ctx.fillStyle = "blue";
		ctx.fill();

    var paddles = [playerPaddle, aiPaddle];
    for (var i in paddles) {
      var paddle = paddles[i];
      ctx.lineWidth = paddle.get('radius')*2;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(paddle.get('p1')[0], paddle.get('p1')[1]);
      ctx.lineTo(paddle.get('p2')[0], paddle.get('p2')[1]);
      ctx.strokeStyle = "black";
      ctx.stroke();
    }

    // touches down
    for (var i = 0; i < game.touchesDown.length; i++) {
      var touch = game.touchesDown[i];
      ctx.beginPath();
      ctx.arc(touch.x, touch.y, 100, 0, 2*Math.PI);
      ctx.closePath();
      ctx.fillStyle = "#FF000080";
      ctx.fill();
    }

    if (game.paused) {
      ctx.fillStyle = "#00000030";
      ctx.fillRect(0,0,game.width,game.height);
      ctx.fillStyle = "#000000";
      ctx.font = "bold 30px arial";
      var txt = "Fullscreen to Unpause";
      var txt_box = ctx.measureText(txt);
      var txt_x = (game.width-txt_box.width)/2;
      var txt_y = (game.height-(txt_box.fontBoundingBoxAscent + txt_box.fontBoundingBoxDescent))/2;
      ctx.fillText(txt, txt_x, txt_y);
    }
	};

	var getAngle = function(paddle) {
		var p1_p2 = mtx.sub_v2(paddle.get('p2'), paddle.get('p1'), mtx.uninit_v2());
		return Math.atan2(p1_p2[1], p1_p2[0]);
	};
	
	var getCenter = function(paddle) {
		return mtx.average_v2(paddle.get('p1'), paddle.get('p2'), mtx.uninit_v2());
	};

	var setAngle = function(paddle, angle) {
		var delta = mtx.create_v2(
			paddleLength*0.5*Math.cos(angle),
			paddleLength*0.5*Math.sin(angle)
		);
		mtx.sub_v2(center, delta, paddle.get('p1'));
		mtx.add_v2(center, delta, paddle.get('p2'));
	};

  game.update = function(dt) {
    if (!isFullscreen()) {
      game.paused = true; 
      return;
    }

    if (isMobileBrowser()) {
      var center = getCenter(playerPaddle); 
      if (game.touchesDown.length === 0) {
        playerPaddlePhysics.velocity[0] = 0;
      } else {
        var x;
        if (game.touchesDown.length === 1) {
          var t = game.touchesDown[0];
          x = t.x;
        } else if (game.touchesDown.length === 2) {
          var t0 = game.touchesDown[0];
          var t1 = game.touchesDown[1];
          if (t1.x < t0.x) {
            var tmp = t0;
            t0 = t1;
            t1 = tmp;
          }
          x = (t0.x+t1.x)/2;
          var dx = t1.x-t0.x;
          var dy = t1.y-t0.y;
          var targetAngle = Math.atan2(dy, dx);
          var paddleAngle = getAngle(playerPaddle);
          if (targetAngle < (paddleAngle-0.05)) {
            paddleAngle -= dt*paddleAngularSpeed;
          } else if (targetAngle > (paddleAngle+0.05)) {
            paddleAngle += dt*paddleAngularSpeed;
          }
					setAngle(playerPaddle, paddleAngle);
        }
        if (x < center[0]-10) {
          playerPaddlePhysics.velocity[0] = -paddleSpeed;
        } else if (x > center[0]+10) {
          playerPaddlePhysics.velocity[0] = paddleSpeed;
        } else {
          playerPaddlePhysics.velocity[0] = 0;
        }
      }
    }

    engine.update(dt);
  };

  game.set_frame_interval(Math.trunc(1000/60)); // ~60fps

  var fs_button = document.getElementById("open_fullscreen");
  fs_button.onclick = function() {
    tryFullscreen(div);
    setTimeout(function() {
      game.paused = false;
    }, 500);
  };

  game.addTouchListener(function(e) {});

  game.print_debug = true;
})();
</script>
</body>
</html>
